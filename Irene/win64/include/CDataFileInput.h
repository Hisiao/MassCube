/******************************************************************************
$HeadURL$

 File: CDataFileInput.h

 Description: Declarations for methods for the reading of standardized
   output data files, generated by the CDataFileOutput class methods.

 Classification:

   Unclassified

 Project Name:

   AE9/AP9/SPM Radiation Environment Models

   Developed under US Government contract # FA9453-12-C-0231

 Rights and Restrictions:

   Copyright 2015 Atmospheric and Environmental Research, Inc. (AER)

   DISTRIBUTION A. Approved for public release; distribution is unlimited.

   The AE9/AP9/SPM software license is contained in the 'documents/Licenses' 
   folder of this distribution file collection.

 Author:

   This software was developed by AER staff

 Contact:

   Atmospheric and Environmental Research, Inc.
   131 Hartwell Avenue
   Lexington, MA 02421-3126 USA
   Phone: 781.761.2288
   email: spwx@aer.com

 References:
 
   None

 Revision history:

  Version      Date        Notes
  1.0          09/18/2015  Created 
  
SVNTag: $Id$
******************************************************************************/

#ifndef CDATAFILEINPUT_H
#define CDATAFILEINPUT_H

#include "CBinFileIO.h"
#include "CAsciiFileIO.h"
#include "CFileIOSpec.h"

#include "VectorTypes.h"

class DataFileInput : public FileIOSpec
{
  public:
    DataFileInput( );
    virtual ~DataFileInput( );

    int setDataFile( const std::string& strFileName, 
                     bool bBinary = false, 
                     const int& iBinId = -1, 
                     bool bMultiFile = false );
    void changeDataFile( const std::string& strFileName );
    std::string getDataFile() { return m_strFileName; }
    int setDataFile( );
    bool hasHeaderSpecs( ) { return m_bHeaderSpecs; }
    std::vector<double> getEnergies( ) { return m_vdEnergies; }
    std::vector<double> getDepths() { return m_vdDoseDepths; }
    int getDataCount() { return m_iDataCount; } // total number of data fields (time is always _single_ MJD value)
    int getDirData()   { return m_iDirData; }   // number of data fields for direction information
    int getNumDir()    { return m_iNumDir; }    // number of directions
    int getNumData()   { return m_iNumData; }   // number of values in data record, excluding time, position and direction info
    int getDataType()  { return m_iDataType; }  // 0=ephemeris,1=flux,2=dose,3=adiabat
    int getFluxType()  { return m_iFluxType; }  // 0=integral,1=1PtDiff,2=2PtDiff
    std::string getModelTag() { return m_strModelTag; } // model name tag (eg 'AE9'. 'AP9', 'PLASMA', etc )
    std::string getSpecies() { return m_strPartSpecies; } // particle species string (ie 'e-', 'H+', 'He+, 'O+')
    std::string getDirDataSource() { return m_strDirDataSource; }

    void getHeaderLines( std::vector<std::string>& strLines ) 
      { strLines = m_strvHeader; }

    // get/set allocated memory buffer, for sharing amongst read of similar files
    double* getDataBuffer();
    void setDataBuffer ( double* pdBuffer );

    int setChunkSize( int iChunkSize );
    int getChunkSize() { return m_iChunkSize; }

    int readDataChunk( dvector& vdTimes,   // time value is always MJD
                       dvector& vdCoord1,  //  coordinate values in 'standard' order
                       dvector& vdCoord2, 
                       dvector& vdCoord3,
                       vvdvector& vvvdData );
    int readDataChunk( dvector& vdTimes,
                       dvector& vdCoord1, 
                       dvector& vdCoord2, 
                       dvector& vdCoord3,
                       vdvector& vvdPitchAngles,
                       vvdvector& vvvdData );
    int readDataChunk( dvector& vdTimes,
                       dvector& vdCoordX, 
                       dvector& vdCoordY, 
                       dvector& vdCoordZ,
                       vdvector& vvdDirX, 
                       vdvector& vvdDirY, 
                       vdvector& vvdDirZ,
                       vdvector& vvdPitchAngles,
                       vvdvector& vvvdData );
    int readTimeChunk( dvector& vdTimes );

    int getNumEntry ( );
    double getLastTime() { return m_dLastTime; }

    int readLoggingChunk( vdvector& vvdLogging );

    // set/get reference value (not used internally)
    void setTagValue( const int& iTagVal ) { m_iTagVal = iTagVal; }
    int getTagValue( ) { return m_iTagVal; }

  protected:

    std::string m_strFileName;
    bool m_bBinaryData;
    bool m_bMultiFile; // if true, file closed after each read
    bool m_bAllocate; // local class buffer allocation
    AsciiFileIO m_asciiFile;
    BinFileIO m_binaryFile;
    int m_iEntryMax;   // maximum number of entries in file
    int m_iChunkSize;
    int m_iEntryCount;  // entry counter for sets of records at same time/pos
    int m_iEntrySize;   // number of doubles in set of records at same time/pos
    double m_dLastTime; // last time entry in current file
    std::map<std::string,int> m_miEntryCount; // map holding file-specific entry counters

    double *m_pdBuffer;
    int m_iDataCount;  // total number of data fields (time is always _single_ MJD value)
    int m_iDirData;    // number of data fields for direction information
    int m_iNumDir;     // number of directions
    int m_iNumData;    // number of values in data record, excluding time, position and direction info
    int m_iDataType;   // 0=ephemeris,1=flux,2=dose,3=adiabat
    int m_iFluxType;   // 0=integral,1=1PtDiff,2=2PtDiff
    int m_iTagVal;     // generic extra data value for external reference
    std::string m_strModelTag;    // model name tag (eg 'AE9'. 'AP9', 'PLASMA', etc )
    std::string m_strPartSpecies; // particle species string (ie 'e-', 'H+', 'He+, 'O+')
    std::vector<double> m_vdEnergies;
    std::vector<double> m_vdDoseDepths;
    bool m_bHeaderSpecs; // flag for presence of file header specifications
    std::string m_strDirDataSource; // header line documenting pitch/dir file source

    // full set of header lines read from file
    std::vector<std::string> m_strvHeader;

    int countAsciiEntries();

    int initDataBuffer();
    int readAsciiDataChunk( dvector& vdTimes,                                      
                            dvector& vdCoord1, 
                            dvector& vdCoord2, 
                            dvector& vdCoord3,                      
                            vdvector& vvdDirX, 
                            vdvector& vvdDirY, 
                            vdvector& vvdDirZ, 
                            vdvector& vvdPitch,  
                            vvdvector& vvvdData );                                                        
    int readAsciiTimeChunk( dvector& vdTimes );
    int extractTimeValue( const dvector& vdLineData,
                          double &dTime );
    int extractTimeCoordValues( const dvector& vdLineData, 
                                double& dDate, 
                                double& dCoord1, 
                                double& dCoord2, 
                                double& dCoord3, 
                                bool bTimeOnly=false );
    int readBinaryDataChunk( dvector& vdTimes,                                     
                             dvector& vdCoord1, 
                             dvector& vdCoord2, 
                             dvector& vdCoord3,                      
                             vdvector& vvdDirX, 
                             vdvector& vvdDirY, 
                             vdvector& vvdDirZ, 
                             vdvector& vvdPitch,  
                             vvdvector& vvvdData );                                                        
    int loadDataChunk( const int& iNumEntry, 
                       dvector& vdTimes,                     
                       dvector& vdCoord1, 
                       dvector& vdCoord2, 
                       dvector& vdCoord3,                      
                       vdvector& vvdDirX, 
                       vdvector& vvdDirY, 
                       vdvector& vvdDirZ, 
                       vdvector& vvdPitch,  
                       vvdvector& vvvdData );                                                        
    void extractHeaderSpecs( const std::string& strLine );                          
};

#endif
