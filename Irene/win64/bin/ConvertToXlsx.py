#!/usr/bin/env python
#=======================================================================================
'''
   The ConvertToXlsx.py script converts various types of model run output files 
   generated by the CmdLineIrene application into corresponding XLSX files.
   Simlarly converts the plot files produced by the IreneGui application.

   The script arguments are simply the name(s) of the ASCII output files to be converted.

   The 'xlsxwriter' python module needs to be installed for this script to operate.
   See  http://xlsxwriter.readthedocs.io/index.html  for more information.
   Suggested (non-root) installation:  easy_install [--prefix=$HOME/.local] xlsxwriter
'''
#=======================================================================================

# enable use of python3 print function form in python 2.x
from __future__ import print_function

import glob
import os.path
import argparse
import numpy as np
import xlsxwriter

# collect list of filenames to be processed from command line arguments
parser = argparse.ArgumentParser(description='convert Irene ASCII-formatted file to xlsx file')
parser.add_argument('infile', type=str, nargs='+', help='name(s) of file to be converted')

args = parser.parse_args()

# need to check for *unexpanded* filename wildcards (ie on Windows)
# - there could be multiple file specifications
wild = set('?*[]')
filelist = []
# loop through list arguments, generate new file list
for kk in range(len(args.infile)):
  # check for existence of wildcard(s) in argument
  if any((c in wild) for c in args.infile[kk]):
    # glob these, add them to new file list (if anything matches)    
    flist = glob.glob( args.infile[kk] )
    if len(flist) > 0:
      filelist.extend( flist )
    else:
      # report any failures in matching filenames to pattern
      print (' ==> no matching files for \"', args.infile[kk], '\" pattern')
  else:
    # add ordinary filename to new file list
    filelist.append( args.infile[kk] )

# loop over full list of file names specified by arguments
for kk in range(len(filelist)):

  # verify that each file exists, skip if not
  if not os.path.isfile(filelist[kk]):
    print ('Error: file \"', filelist[kk], '\" does not exist - skipping')
    continue

  print (' processing input file ',filelist[kk])
  # initialize variables
  delim = ' '
  header = []
  tlist = []
  dlist = []
  elist = []
  plotfile = 0
  units=''

  # first open file to read header lines only
  fs = open(filelist[kk],"r") 

  line = fs.readline().rstrip()
  while line.startswith('#'):

    # detect if file is plot output from GUI
    if line.find("plot data from Model")>0:
      plotfile = 1
      
    # get data delimiter setting for data collection step
    if line.find("elimiter")>0:
      if line.find("comma")>0:
        delim = ','
      if line.find("space")>0:
        delim = ' '
      if line.find("tab")>0:
        delim = '\t'
      # read next header line without saving this one
      line = fs.readline().rstrip()
      continue

    # save all header lines except delimiter
    header.append( line )

    # query header line for other details needed
    #  -- get list of energy (as strings; 2ptDif will be in '<e1>-<e2>' form
    if line.find("Energy levels")>0:
      elist = line[line.find(":")+1:].split() # split on whitespace
      units = line[line.find("(")+1:line.find(")")]
    #  -- get list of shielding depths
    if line.find("Shielding depths")>0:  # overwrites elist, as intended
      elist = line[line.find(":")+1:].split() # split on whitespace
      units = line[line.find("(")+1:line.find(")")]
    #  -- separate out the time specification fields
    if line.find("datetime(")>0:
      tlist = line[line.find("(")+1:line.find(")")].split(",")
      dlist = line[line.find(")")+2:].split(",")

    # when plot file detected, look for specific strings on header line
    #  to properly extract the file's data column labels
    if plotfile:
      if line.find("Time (")>0 or line.find("Energy (")>0 or line.find("Thickness (")>0:
        # get x-axis variable label: format = "<name> (<units>)"
        eref = line.find(")")+1
        dlist.append( line[2:eref] )
        # advance over space, look for y-axis variable labels: format = "'<name'"
        bref = eref+2
        # find first column label's ending single quote mark
        eref = line.find("'",bref)
        # add to data column name to list (exclude the single quote marks)
        #   then look for next column's ending quote mark, until no more are found
        while eref>0:
          dlist.append( line[bref:eref] )
          bref = eref+3
          eref = line.find("'",bref)
          
    # read next line
    line = fs.readline().rstrip()

  # finished reading header lines - close file
  fs.close()

  # slurp up data into 2-d vector, keying on specified data delimiter
  #  header (comment) lines in file are automatically ignored
  data = np.loadtxt(filelist[kk],delimiter=delim)

  # output filename is same as input, except replacing extension with 'xlsx'
  outfile = filelist[kk].rsplit( ".", 1 )[ 0 ]+".xlsx"
  print ('  -->writing to file: ',outfile)

  # open new xlsx file for output
  workbook = xlsxwriter.Workbook( outfile )
  worksheet = workbook.add_worksheet()

  # start at begining
  row = 0
  col = 0
  # write each line of header (except data delimiter)
  for ii in range(len(header)-1):
    worksheet.write_string( row, col, header[ii] )
    row = row + 1

  # annotate either energy levels or shielding depths
  #   just above their associated columns
  # (does not apply for adiabatic coord or ephem output files)
  if len(elist)>0:
    worksheet.write_string( row, col, "#")
    off = (len(dlist) + len(tlist)) - len(elist)
    for jj in range(len(elist)):
      worksheet.write_string( row, off+jj, elist[jj]+" "+units )
    row = row + 1

  # write time and data column labels in bold text
  bold = workbook.add_format({'bold': 1})
  for jj in range(len(tlist)):
    worksheet.write_string( row, col, tlist[jj], bold )
    col = col + 1
  for jj in range(len(dlist)):
    worksheet.write_string( row, col, dlist[jj], bold )
    col = col + 1
  row = row + 1

  # add setting to freeze header portion of spreadsheet
  #  all row below, containing the results, scrolls
  worksheet.freeze_panes(row,0)
  numhead = row

  # loop through full set of data, writing to appropriate cells
  if len(data.shape)==1:
    col = 0
    for jj in range(data.shape[0]):
      worksheet.write_number(row,col, data[jj] )
      col = col + 1
    row = row + 1
  else:
    for ii in range(data.shape[0]):
      col = 0
      for jj in range(data.shape[1]):
        worksheet.write_number(row,col, data[ii][jj] )
        col = col + 1
      row = row + 1

  # close completed xlsx file, report number of rows made
  workbook.close()
  print ('    ',row-numhead,'data rows written')

  #--- continue processing files, until all have been processed.
